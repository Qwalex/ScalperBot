## Скальпинг-бот на Bybit (Node.js)

### Стек
- Node.js 18+
- bybit-api (V5 REST/WS)
- WebSocket (L1 ордербук), REST (создание/отмена ордеров)
- dotenv, pino, Bottleneck

### Структура
- `src/config.js` — загрузка `.env`, все параметры бота
- `src/logger.js` — логгер (pretty по `LOG_PRETTY`)
- `src/exchange/bybit.js` — обёртка Bybit: REST/WS, округления, выставление/отмена
- `src/strategy/scalper.js` — стратегия скальпинга
- `src/index.js` — запуск бота

### Быстрый старт
1) Установите зависимости: `npm i`
2) Создайте `.env` (см. пример полей ниже)
3) Запуск (dev): `npm run dev`
4) Запуск (prod): `npm start`

### Переменные окружения (.env)
- `BYBIT_KEY`, `BYBIT_SECRET` — API‑ключи
- `BYBIT_TESTNET` — `true` для тестнета, `false` для боевого
- `CATEGORY` — `linear|inverse|spot|option` (для фьючерсного скальпинга используйте `linear`)
- `SYMBOL` — инструмент, например `BTCUSDT`
- `LEVERAGE` — плечо (derivatives)
- `ORDER_QTY` — размер заявки (учтите `minOrderQty` из логов инструмента)
- `MIN_SPREAD_TICKS` — минимальный спред в тиках, при котором бот котирует
- `CANCEL_AFTER_MS` — через сколько мс снимать неисполненные заявки
- `TIME_IN_FORCE` — обычно `PostOnly`
- `DRY_RUN` — `true` не отправляет ордера, только логи; `false` — реальные заявки
- `LOG_LEVEL` — `info|debug|warn|error`
- `LOG_PRETTY` — `true` для красивых логов

### Логика стратегии (как бот торгует)
Идея — становиться мейкером, когда спред достаточен, улучшая лучшие цены на 1 тик и быстро снимать неисполненные заявки.

Поток:
1) Инициализация:
   - Запрос инфо по инструменту (tickSize, qtyStep, minOrderQty) — для корректных округлений
   - Установка плеча (для `linear`/`inverse`, если `DRY_RUN=false`)
   - Подключение к публичному WS V5 и подписка на `orderbook.1.SYMBOL`
   - (Если заданы ключи) Подключение к приватному WS V5 и подписка на `order`

2) Обновления книги (L1):
   - Получаем `bestBid` и `bestAsk`
   - Считаем спред в тиках: `(bestAsk - bestBid) / tickSize`
   - Если `spreadTicks >= MIN_SPREAD_TICKS`:
     - Ставим лимит‐покупку по `bestBid + tickSize` (улучшение бидов на 1 тик)
     - Ставим лимит‐продажу по `bestAsk - tickSize` (улучшение асков на 1 тик)
     - Все цены и количества округляются по `tickSize/qtyStep`, `ORDER_QTY >= minOrderQty`
     - Ордеры отправляются с `timeInForce=PostOnly` (избежать немедленного исполнения)

3) Отмена:
   - Для каждого ордера запускается таймер на `CANCEL_AFTER_MS`
   - Если ордер не исполнен — бот вызывает REST `cancelOrder`
   - Лимит открытых заявок ограничен `MAX_OPEN_ORDERS`

4) Приватный поток:
   - Слушает `order` события (используется для отладки/расширений)

Защита/проверки:
- Все цены/объёмы валидируются по фильтрам инструмента
- Используется `orderLinkId` для надёжной отмены (поддержка отмены по `orderId` и `orderLinkId`)
- Обязательная проверка `retCode`/`retMsg` после `submitOrder`

### Типовые настройки
- Наблюдать ордера подольше: `CANCEL_AFTER_MS=5000..8000`
- Меньше спама: `MIN_SPREAD_TICKS=3..5`
- Увидеть частое котирование: `MIN_SPREAD_TICKS=0..1`

### Где смотреть заявки
- Testnet: раздел деривативов (USDT Perpetual) → Open Orders по вашему `SYMBOL`
- В логах: строки `Order placed` и затем `Order cancelled` (если отменены)

### Траблшутинг
- Ордеры не видны в UI, но есть `Order placed` в логах:
  - Убедитесь, что вы смотрите именно тестовый кабинет и нужный раздел деривативов
  - Проверьте фильтры по символу/времени/типу ордера
  - Смотрите ошибки `Order not accepted` (если появятся)
- ESM ошибка `pino-pretty`: используйте `LOG_PRETTY=true` вместо пайпа в скрипте
- Hedge‐mode: при необходимости можно добавить `positionIdx` в `submitOrder`

### Безопасность
- Никогда не коммитьте `.env`
- Регулярно перевыпускайте ключи
- Торговля на реале — на ваш риск; протестируйте на тестнете

### Планы на улучшения
- Учет комиссий и минимального профита
- Smart re‐quote по очереди книги
- ТП/СЛ через `setTradingStop` для позиционных сценариев

